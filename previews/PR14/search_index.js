var documenterSearchIndex = {"docs":
[{"location":"#ContextVariablesX.jl","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"","category":"section"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"ContextVariablesX.jl is heavily inspired by contextvars in Python (see also PEP 567).","category":"page"},{"location":"#Tutorial","page":"ContextVariablesX.jl","title":"Tutorial","text":"","category":"section"},{"location":"#Basic-usage","page":"ContextVariablesX.jl","title":"Basic usage","text":"","category":"section"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"Context variables can be used to manage task-local states that are inherited to child tasks.  Context variables are created by @contextvar:","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"@contextvar cvar1           # untyped, without default\n@contextvar cvar2 = 1       # typed (Int), with default\n@contextvar cvar3::Int      # typed, without default","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"Note that running above code in REPL will throw an error because this form work only within a package namespace.  To play with @contextvar in REPL, you can prefix the variable name with global:","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"DocTestSetup = quote\n    using ContextVariablesX\n    ContextVariablesX._WARN_DYNAMIC_KEY[] = false\n    function display(x)\n        show(stdout, \"text/plain\", x)\n        println()\n    end\nend","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> @contextvar x::Any = 1;","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"warning: Warning\n@contextvar outside a proper package should be used only for interactive exploration, quick scripting, and testing.  Using @contextvar outside packages make it impossible to work with serialization-based libraries such as Distributed.","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"You can be get a context variable with indexing syntax []","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> x[]\n1","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"It's not possible to set a context variable.  But it's possible to run code inside a new context with new values bound to the context variables:","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> with_context(x => 100) do\n           x[]\n       end\n100","category":"page"},{"location":"#Dynamic-scoping","page":"ContextVariablesX.jl","title":"Dynamic scoping","text":"","category":"section"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"with_context can be used to set multiple context variables at once, run a function in this context, and then rollback them to the original state:","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> @contextvar y = 1;\n       @contextvar z::Int;","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> function demo1()\n           @show x[]\n           @show y[]\n           @show z[]\n       end;\n\njulia> with_context(demo1, x => :a, z => 0);\nx[] = :a\ny[] = 1\nz[] = 0","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"Note that with_context(f, x => nothing, ...) clears the value of x, rather than setting the value of x to nothing.  Use Some(nothing) to set nothing.  Similar caution applies to set_context (see below).","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> with_context(x => Some(nothing), y => nothing, z => nothing) do\n           @show x[]\n           @show y[]\n           @show get(z)\n       end;\nx[] = nothing\ny[] = 1\nget(z) = nothing","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"Thus,","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"with_context(x => Some(a), y => Some(b), z => nothing) do\n    ...\nend","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"can be used considered as a dynamically scoped version of","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"let x′ = a, y′ = b, z′\n    ...\nend","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"Use with_context(f, nothing) to create an empty context and rollback the entire context to the state just before calling it.","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> with_context(y => 100) do\n           @show y[]\n           with_context(nothing) do\n               @show y[]\n           end\n       end;\ny[] = 100\ny[] = 1","category":"page"},{"location":"#Snapshot","page":"ContextVariablesX.jl","title":"Snapshot","text":"","category":"section"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"A handle to the snapshot of the current context can be obtained with snapshot_context.  It can be later restored by with_context.","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> x[]\n1\n\njulia> snapshot = snapshot_context();\n\njulia> with_context(x => 100) do\n           with_context(snapshot) do\n               @show x[]\n           end\n       end;\nx[] = 1","category":"page"},{"location":"#Concurrent-access","page":"ContextVariablesX.jl","title":"Concurrent access","text":"","category":"section"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"The context is inherited to the child task when the task is created. Thus, changes made after @async/@spawn or changes made in other tasks are not observable:","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> function demo2()\n           x0 = x[]\n           with_context(x => x0 + 1) do\n               (x0, x[])\n           end\n       end\n\njulia> with_context(x => 1) do\n           @sync begin\n               t1 = @async demo2()\n               t2 = @async demo2()\n               result = demo2()\n               [result, fetch(t1), fetch(t2)]\n           end\n       end\n3-element Array{Tuple{Int64,Int64},1}:\n (1, 2)\n (1, 2)\n (1, 2)","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"In particular, manipulating context variables using the public API is always data-race-free.","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"warning: Warning\nIf a context variable holds a mutable value, it is a data-race to mutate the value when other threads are reading it.@contextvar local x = [1]  # mutable value\n@sync begin\n    @spawn begin\n        value = x[]        # not a data-race\n        push!(value, 2)    # data-race\n    end\n    @spawn begin\n        value = x[]        # not a data-race\n        @show last(value)  # data-race\n    end\nend","category":"page"},{"location":"#Namespace","page":"ContextVariablesX.jl","title":"Namespace","text":"","category":"section"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"Consider \"packages\" and modules with the same variable name:","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> module PackageA\n           using ContextVariablesX\n           @contextvar x = 1\n           module SubModule\n               using ContextVariablesX\n               @contextvar x = 2\n           end\n       end;\n\njulia> module PackageB\n           using ContextVariablesX\n           @contextvar x = 3\n       end;","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"These packages define are three distinct context variables PackageA.x, PackageA.SubModule.x, and PackageB.x that can be manipulated independently.","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"This is simply because @contextvar creates independent variable \"instance\" in each context.  It can be demonstrated easily in the REPL:","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"julia> PackageA.x\nMain.PackageA.x :: ContextVar [668bafe1-c075-48ae-a52d-13543cf06ddb] => 1\n\njulia> PackageA.SubModule.x\nMain.PackageA.SubModule.x :: ContextVar [0549256b-1914-4fcd-ac8e-33f377be816e] => 2\n\njulia> PackageB.x\nMain.PackageB.x :: ContextVar [ddd3358e-a77f-44c0-be28-e5dde929c6f5] => 3\n\njulia> (PackageA.x[], PackageA.SubModule.x[], PackageB.x[])\n(1, 2, 3)\n\njulia> with_context(PackageA.x => 10, PackageA.SubModule.x => 20, PackageB.x => 30) do\n           display(PackageA.x)\n           display(PackageA.SubModule.x)\n           display(PackageB.x)\n           (PackageA.x[], PackageA.SubModule.x[], PackageB.x[])\n       end\nMain.PackageA.x :: ContextVar [668bafe1-c075-48ae-a52d-13543cf06ddb] => 10\nMain.PackageA.SubModule.x :: ContextVar [0549256b-1914-4fcd-ac8e-33f377be816e] => 20\nMain.PackageB.x :: ContextVar [ddd3358e-a77f-44c0-be28-e5dde929c6f5] => 30\n(10, 20, 30)","category":"page"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"DocTestSetup = nothing","category":"page"},{"location":"#Reference","page":"ContextVariablesX.jl","title":"Reference","text":"","category":"section"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"Modules = [ContextVariablesX]\nPrivate = false","category":"page"},{"location":"#ContextVariablesX.ContextVar","page":"ContextVariablesX.jl","title":"ContextVariablesX.ContextVar","text":"ContextVar{T}\n\nContext variable type.  This is the type of the object var created by @contextvar var.  This acts as a reference to the value stored in a task-local context.  The macro @contextvar is the only public API to construct this object.\n\nwarning: Warning\nIt is unspecified if this type is concrete or not. It may be changed to an abstract type and/or include more type parameters in the future.\n\n\n\n\n\n","category":"type"},{"location":"#Base.get-Union{Tuple{ContextVar{T}}, Tuple{T}} where T","page":"ContextVariablesX.jl","title":"Base.get","text":"get(var::ContextVar{T}) -> Union{Some{T},Nothing}\n\nReturn Some(value) if value is assigned to var.  Return nothing if unassigned.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{ContextVar{T}}, Tuple{T}} where T","page":"ContextVariablesX.jl","title":"Base.getindex","text":"getindex(var::ContextVar{T}) -> value::T\n\nReturn the value assigned to var.  Throw a KeyError if unassigned.\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariablesX.snapshot_context-Tuple{}","page":"ContextVariablesX.jl","title":"ContextVariablesX.snapshot_context","text":"snapshot_context() -> snapshot::ContextSnapshot\n\nGet a snapshot of a context that can be passed to with_context to run a function inside the current context at later time.\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariablesX.with_context","page":"ContextVariablesX.jl","title":"ContextVariablesX.with_context","text":"with_context(f, var1 => value1, var2 => value2, ...)\nwith_context(f, pairs)\n\nRun f in a context with given values set to the context variables.  Variables specified in this form are rolled back to the original value when with_context returns.  It act like a dynamically scoped let.  If nothing is passed as a value, corresponding context variable is cleared; i.e., it is unassigned or takes the default value.  Use Some(value) to set value if value can be nothing.\n\nwith_context(f, nothing)\n\nRun f in a new empty context.  All variables are rewind to the original values when with_context returns.\n\nNote that\n\nvar2[] = value2\nwith_context(var1 => value1) do\n    @show var2[]  # shows value2\n    var3[] = value3\nend\n@show var3[]  # shows value3\n\nand\n\nvar2[] = value2\nwith_context(nothing) do\n    var1[] = value1\n    @show var2[]  # shows default (or throws)\n    var3[] = value3\nend\n@show var3[]  # does not show value3\n\nare not equivalent.\n\n\n\n\n\n","category":"function"},{"location":"#ContextVariablesX.@contextvar-Tuple{Any}","page":"ContextVariablesX.jl","title":"ContextVariablesX.@contextvar","text":"@contextvar var[::T] [= default]\n\nDeclare a context variable named var.  The type constraint ::T and the default value = default are optional.  If the default value is given without the type constraint ::T, its type T = typeof(default) is used.\n\nwarning: Warning\nContext variables defined outside a proper package does not work with Distributed.\n\nExamples\n\nTop-level context variables needs to be declared in a package:\n\nmodule MyPackage\n@contextvar cvar1\n@contextvar cvar2 = 1\n@contextvar cvar3::Int\nend\n\n\n\n\n\n","category":"macro"},{"location":"","page":"ContextVariablesX.jl","title":"ContextVariablesX.jl","text":"ContextVariablesX.with_logger","category":"page"},{"location":"#ContextVariablesX.with_logger","page":"ContextVariablesX.jl","title":"ContextVariablesX.with_logger","text":"ContextVariablesX.with_logger(f, logger::AbstractLogger)\n\nLike Logging.with_logger but properly propagate the context variables.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [ContextVariablesX]\nPublic = false","category":"page"},{"location":"internals/#ContextVariablesX.genkey-Tuple{Module,Symbol}","page":"Internals","title":"ContextVariablesX.genkey","text":"genkey(__module__::Module, varname::Symbol) -> Union{UUID,Nothing}.\n\nGenerate a stable UUID for a context variable __module__.$varname.\n\n\n\n\n\n","category":"method"},{"location":"internals/#ContextVariablesX.merge_ctxvars-Tuple{Any,Any}","page":"Internals","title":"ContextVariablesX.merge_ctxvars","text":"merge_ctxvars(ctx::Union{Nothing,T}, kvs) -> ctx′:: Union{Nothing,T}\n\nwarning: Warning\nThis is not a public API.  This documentation is for making it easier to experiment with different implementations of the context variable storage backend, by monkey-patching it at run-time.  When this function is monkey-patched, ctxvars_type should also be monkey-patched to return the type T.\n\nThe first argument ctx is either nothing or a dict-like object of type T where its keytype is UUID and valtype is Any.  The second argument kvs is an iterable of Pair{UUID,<:Union{Some,Nothing}} values.  Iterable kvs must have length.\n\nIf ctx is nothing and kvs is non-empty, merge_ctxvars creates a new instance of T. If ctx is not nothing, it returns a shallow-copy ctx′ of ctx where k => v is inserted to ctx′ for each k => Some(v) in kvs and k is deleted from ctx′ for each k => nothing in kvs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#ContextVariablesX.with_logger-Tuple{Any,Base.CoreLogging.AbstractLogger}","page":"Internals","title":"ContextVariablesX.with_logger","text":"ContextVariablesX.with_logger(f, logger::AbstractLogger)\n\nLike Logging.with_logger but properly propagate the context variables.\n\n\n\n\n\n","category":"method"}]
}
